---
title: 'redux原理解析'
description: HerryLo, 微信公众号： Yopai
data: 2019-10-26
tags: redux原理解析
---

## redux解析

作者: [HerryLo](https://github.com/HerryLo)

[本文永久有效链接: https://github.com/AttemptWeb......]()

Redux 是 JavaScript 状态容器，提供可预测化的状态管理。

在实际开发中，常搭配React + React-redux使用。这代表了目前前端开发的一个基本理念，**数据和视图的分离**。

redux应运而生，当然还有其他的一些状态管理库，如Flux、Elm等，当然，我们这里只对redux进行解析。

## 创建Store

首先会生成store对象，需要调用combineReducers和createStore函数，下面解释不包含中间件。

```javascript
const reducer = combineReducers({
    home: homeNumber,
    number: addNumber
})
const store = createStore(reducer)
// 暂时挂载在window下
window.$reduxStore = store
```
下面来对源码进行分析，调用函数如下：

![](/20191026/15725323927952.jpg)
### combineReducers函数

首先调用combineReducers函数，将多个reducer函数作为参数传入，源码如下：

```javascript
// reducers即是传入的参数对象
function combineReducers(reducers) {
    // ......省略
    return function combination(state = {}, action) {
        let hasChanged = false
        const nextState: StateFromReducersMapObject<typeof reducers> = {}
        for (let i = 0; i < finalReducerKeys.length; i++) {
            // finalReducerKeys 是传入reducers对象的key值
            const key = finalReducerKeys[i]
            // finalReducers就是传入的参数对象
            const reducer = finalReducers[key]
            const previousStateForKey = state[key]
            // 运行reducer函数，返回一个state
            // 核心：调用combination函数，实际就是循环调用传入的reducer函数
            const nextStateForKey = reducer(previousStateForKey, action)

            nextState[key] = nextStateForKey
        }
        // 返回state对象
        return nextState
    }
}
// 源码地址：https://github.com/reduxjs/redux/blob/master/src/combineReducers.ts#L139
```
函数内部整合返回一个新的函数，上面的代码其实非常简单，返回一个新的combination函数。**combination函数的主要作用是返回一个挂载全部state的对象**。 **当combination函数被调用时，实际就是循环调用传入的reducer函数，返回state对象**。将combination函数作为参数传入到createStore函数中。

### createStore函数

```javascript
function createStore(reducer, preloadedState, enhancer) {
    // reducer --> combination函数
    let currentReducer = reducer
    // 全部的state属性，挂载在currentState上
    let currentState = preloadedState

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
        // 第二个参数是一个函数，没有第三个参数的情况
        enhancer = preloadedState
        // 将preloadedState重置
        preloadedState = undefined
    }
    if (typeof enhancer !== 'undefined') {
        // 存在中间件时，将createStore传入中间件函数，下面会讲到。
        return enhancer(createStore)(reducer, preloadedState)
    }

    function dispatch(action) {
        // currentReducer --> combination函数
        currentState = currentReducer(currentState, action)
    }

    // 初始化调用dispatch，创建初始state
    dispatch({ type: ActionTypes.INIT })

    const store = ({
        dispatch: dispatch,
        subscribe,s
        getState,
        replaceReducer,
        [$$observable]: observable
    }
    return store
}
// 源码地址：https://github.com/reduxjs/redux/blob/master/src/createStore.ts#L60
```
**```reducer```就是传入的combination函数，preloadedState是初始化的state，enhancer是中间件**，没有第三个参数的情况下，同时第二个参数是一个函数，preloadedState被赋值给enhancer。

调用```dispatch```函数，创建state，返回store对象。**```currentReducer```即是传入```combination```函数**，就向上文提到的，**调用```combination```函数实际就是循环调用reducer函数**。所有的state对象，被挂载在内部变量```currentState```上。**```enhancer```**中间件我们会在下面讲到。

**创建的store对象**，暴露出的方法如下： 

```javascript
const store = ({
    // 分发 action，这是触发 state 变化的惟一途径。
    dispatch: dispatch as Dispatch<A>,
    // 变化监听器
    subscribe,
    // 获取store下的 全部state
    getState,
    // 替换 store 当前用来计算 state 的 reducer
    replaceReducer
}
return store
```
```dispatch```函数触发action，调用reducer函数，修改state。```subscribe```函数可以监听变化state的变化。```getState```函数获取全部state。```replaceReducer```函数替换用来计算state的```reducer```函数。

## redux中间件

```redux-thunk```只是redux中间件的一种，也是比较常见的中间件。```redux-thunk```库允许你编写与store交互的异步逻辑。

```javascript
import thunkMiddleware from 'redux-thunk'
const reducer = combineReducers({
    home: homeNumber,
    number: addNumber
})

const store = createStore(
    reducer,
    applyMiddleware(
        thunkMiddleware, // 允许我们 dispatch() 函数
    )
)
```
```redux-thunk```库内部源码非常的简单，[github: redux-thunk 源码](https://github.com/reduxjs/redux-thunk/blob/master/src/index.js)，允许action是一个函数，同时支持参数传递，否则调用方法不变。

### applyMiddleware函数

我们还是回到redux的中间件上，从applyMiddleware函数开始。

```javascript
// 支持多个中间件传入
export default function applyMiddleware(
  ...middlewares
) {
  return (createStore) => (reducer, ...args) => {
    // 创建 store
    const store = createStore(reducer, ...args)

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    }
    // 运行中间件函数，将middlewareAPI作为参数传入
    const chain = middlewares.map(middleware => middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

    // 照常返回一个store对象 
    return {
      ...store,
      dispatch
    }
  }
}
```
```applyMiddleware```函数接收多个middlewares参数，返回一个store对象。


```redux-thunk```库的核心代码如下：
```javascript
    return ({ dispatch, getState }) => (next) => (action) => {
        if (typeof action === 'function') {
        return action(dispatch, getState, extraArgument);
        }
        return next(action);
    };
```



### redux使用





