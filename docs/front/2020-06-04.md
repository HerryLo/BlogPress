---
title: 聊一聊！ES6中的Iterator迭代器
description: HerryLo, 微信公众号： Yopai
date: 2020-06-04 23:50
tags: Iterator
---

# 聊一聊！ES6中的Iterator迭代器

专门说一说`Iterator`迭代器的原因是，为后面`async/await`的文章做铺垫，因为我`async/await`是由`Generator`+`Promise`共同构成，而其中的`Generator`就是依赖于迭代器`Iterator`。

下面让我们来看看什么是`Iterator`？它出现的目的是什么？如何使用它？

## `Iterator`迭代器

> 名词： 迭代 iteration / 可迭代 iterable / 迭代器 iterator

想必大家使用过for循环、while循环等，遍历Array获取其中的值，那其他数据结构如何通过遍历获取呢？或者这样说，是否可以提供一个统一的访问机制？来访问Object、Map、Set等。

轮到`Iterator`迭代器出场，`Iterator`迭代器就是为了解决这个问题，它提供统一的接口，为**不同的数据结构提供统一的访问机制**。(目前Map、Set、Array支持`Iterator`)。

顾名思义，`Iterator`迭代器的出现就是为了迭代而生，为不同的集合：Object、Array、Map、Set，提供了一个统一的接口（这里接口可以简单的理解为方法，就是遍历方法）。向我们常用的`for...of`就是依赖与`Iterator`迭代器。

在这里顺便提一嘴，我理解到的遍历、迭代的关系：遍历就是访问数据结构的所有元素，而迭代是遍历的一种形式。

```javascript
// 阮一峰 ECMAScript 6 入门
// 模拟next方法返回值
var it = makeIterator(['a', 'b']);

it.next() // { value: "a", done: false }
it.next() // { value: "b", done: false }
it.next() // { value: undefined, done: true }

function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex < array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true}
    }
  }
}
```
上面的`makeIterator`函数，它就是一个`迭代器生成函数`，作用就是返回一个**迭代器对象**。对数组执行这个函数，就会返回该数组的**迭代器对象it**。

通过调用`next`函数，返回`value`和`done`两个属性；value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法；当`done`为true时，即遍历完成。

```javascript
// 阮一峰 ECMAScript 6 入门 
// Iterator迭代器运行的流程
Iterator 的遍历过程是这样的。

（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。

（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。

（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。
// 这里的指针对象可以理解为引用对象
```

**小结**：`Iterator`迭代器就是一个接口方法，它为不同的数据结构提供了一个统一的访问机制；使得数据结构的成员能够按某种次序排列，并逐个被访问。

## `Iterator`和`Generator`

`Generator`和`Promise`一样，都是提供异步编程解决方案。其实Generator函数就是一个普通函数，但是有两个特征，一是，function关键字与函数名之间有一个星号*；二是，函数内部使用yield表达式，定义不同的内部状态。来看看Generator函数的使用：
```javascript
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();
hw.next()
// { value: 'hello', done: false }
hw.next()
// { value: 'world', done: false }
hw.next()
// { value: 'ending', done: true }
hw.next()
// { value: undefined, done: true }
```
通过上面的例子可以知道，`Generator`函数执行后，会返回一个`Iterator`对象。在`Generator`中的yield表达式，yield会记住当前代码运行的状态和位置，等在调用这串代码的时候会依次往后走。

`Iterator`（迭代器）就是一个可迭代的对象，而`Generator`（生成器）使用了yield或者生成器表达式，生成iterator对象，用一种方便的方法实现了iterator，在for循环取数据或使用next()取数据.

**小结**：`Generator`（生成器）可以理解为是对`Iterator`（迭代器）的一种实现。

## `Iterator`应用

`Generator`（生成器）就是其中最典型的一个应用，当然还有其他，例如：Map、Set、Array等原生具备`Iterator`（迭代器），支持`for...of`循环。Object对象虽然不支持`Iterator`（迭代器），但我们可以使用`Generator`（生成器）进行包装。

```javascript
let obj = {a: 1, b: 2}
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}
for (let [key, value] of entries(obj)) {
  console.log(key, '->', value);
}
```

参考：

[阮一峰：Iterator 和 for...of 循环](https://es6.ruanyifeng.com/#docs/iterator#Iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5)

[白话解释 迭代器(ITERATOR)和生成器(GENERATOR)](https://segmentfault.com/a/1190000007208388)

[Python/Iterator and Generator 关系](https://blog.csdn.net/qq_39591494/article/details/88729640)

**ps**: 微信公众号：Yopai，有兴趣的可以关注，每周不定期更新。不断分享，不断进步

![](/webChat1.png)

